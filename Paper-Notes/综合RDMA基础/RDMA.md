### 区分广域RDMA推理、训练
#### 第一步：打破概念——什么是广域 RDMA？

想象你在做一个复杂的拼图（处理数据）。

1. **传统网络（TCP/IP）：** 就像你要拿一块拼图，必须先写申请单，交给管家（操作系统内核），管家检查后交给快递员（网卡），快递员开车送到隔壁房间，对方管家收件、拆包，再把拼图给你。**手续繁琐，延迟高。**
    
2. **RDMA（远程直接内存访问）：** 就像你有一只伸缩自如的“魔法手”。你可以直接穿墙伸到隔壁房间的桌子上，把拼图拿过来。**没有中间商，极快。**
    

**那么，“广域”是什么意思？** 通常 RDMA 用在同一个数据中心里（几米距离）。“广域”就是把这只“魔法手”伸得很长，比如从北京伸到上海。虽然手很快，但因为距离远，物理上的“光速延迟”和网络抖动变得无法忽视。

#### 第二步：场景对比——训练 vs. 推理

现在我们有了“魔法长手”，我们来看看它在两个不同场景下的表现。

##### 场景一：AI 训练（Training）——“千人同心”的阅兵式

**核心特征：频繁同步、极度敏感。**

训练一个大模型（比如 GPT-4），就像是训练一支 1000 人的仪仗队走正步。

- **每一次迈步（迭代）：** 所有人必须动作完全一致。
    
- **同步（All-Reduce）：** 每走一步，大家都要停下来互相确认：“刚才我抬腿高了 1 厘米，你们呢？”（同步梯度参数）。只要有一个人动作慢了，或者传递消息慢了，**所有人都要等他**。
    

**广域 RDMA 在这里的挑战：** 如果你把这 1000 人的一半放在北京，一半放在上海，用广域 RDMA 让他们通过视频连线来走正步。

- **问题：** 虽然 RDMA 这只手很快，但光从北京跑到上海也需要时间（物理延迟）。
    
- **结果：** 整个仪仗队的速度会被最远的那个距离“拖累”致死。训练效率会由原来的“跑步前进”变成“慢动作回放”。
    

> **结论：** 在训练中，广域 RDMA 主要是为了解决算力不足的**无奈之举**（比如单地机房电力不够了），或者是为了做**异步检查点保存**（把数据备份到远处）。直接跨广域网做紧密耦合的训练，是非常痛苦且低效的。

##### 场景二：AI 推理（Inference）——“接力赛”式的流水线

**核心特征：流水作业、吞吐优先。**

推理是你问 ChatGPT 一个问题，它回答你。这就像是一场接力赛或者是工厂流水线。

- **过程：** 比如“预填充（Prefill）”阶段处理你的长问题，然后“解码（Decode）”阶段一个字一个字吐出答案。
    
- **并不需要所有人同时停下来：** 第一棒跑完，把棒子（KV Cache 数据）交给第二棒就行。
    

**广域 RDMA 在这里的机会：** 现在的推理正在流行一种**“算力分离”**的架构。

- **例子：** 也许处理长文本的“重活”（Prefill）在算力便宜的贵州机房做，而需要快速反应的“轻活”（Decode）在靠近用户的上海机房做。
    
- **RDMA 的作用：** 当贵州做完后，需要把生成的巨大的中间状态数据（KV Cache），用那只“魔法长手”瞬间扔给上海的机器。
    

在这，广域 RDMA 非常有用！因为它主要负责**搬运大块数据**。虽然有物理延迟，但这是一次性的搬运，而不是像训练那样每毫秒都要同步一次。

|**特性**|**AI 训练 (Training)**|**AI 推理 (Inference)**|
|---|---|---|
|**通俗类比**|**合唱团**：所有人必须同时换气，一人卡顿，全员翻车。|**接力跑**：这一棒跑完交接给下一棒，允许由于距离产生的交接时间。|
|**数据交互模式**|**All-to-All**：每一块 GPU 都要和别的 GPU 频繁说话（交换梯度）。|**Pipeline / Data Fetch**：点对点传输，或者把生成好的“状态”搬运到某处。|
|**对网络抖动的容忍度**|**零容忍**：木桶效应，最慢的网络连接决定整体速度。|**中等容忍**：只要总耗时在用户能接受的范围内（比如 200ms），中间传数据慢一点点可以接受。|
|**广域 RDMA 的价值**|**低（但在探索中）**：受限于光速物理定律，主要用于容灾或非紧密计算。|**高**：用于“潮汐调度”，跨数据中心传输巨大的 KV Cache，实现算力最优化。|
####
这里的直觉是什么？（Feynman Insight）

**训练是关于“一致性”的，而推理是关于“流动性”的。**

- **训练**像是在**甚至**混凝土地基，必须所有材料同时凝固，广域网的距离会把“同时”撕裂。
    
- **推理**像是**输送**水流，广域 RDMA 就像一根超粗的高压水管（高带宽），虽然水从源头流到龙头需要一点时间（延迟），但一旦开始流，水量巨大且源源不断。

### 实践

首先回答你的问题：**不需要租 AutoDL！**

AutoDL 主要是用来租 GPU（显卡）跑深度学习模型的。而 Soft-RoCE 是利用 **CPU 和 内存** 来模拟网络行为，对显卡没有要求。

**你只需要：** 一台电脑（Windows 或 Mac 均可），安装好 **VirtualBox** 或 **VMware**（免费版即可）。

我们要做的，是在你的电脑里开 **两台** 小小的 Linux 虚拟机（我们叫它 VM1 和 VM2），假装它们是两台相隔万里的服务器。

准备好了吗？我们将把你的电脑变成一个微型的“数据中心”。请跟随以下步骤：

---

### 第一步：准备“实验台”（环境搭建）

我们需要两台 Ubuntu 虚拟机。

1. **安装虚拟机软件：** 下载并安装 VirtualBox。
    
2. **创建两台 Ubuntu 虚拟机：**
    
    - 下载 Ubuntu Server 22.04 (或者 20.04) 的 ISO 镜像。
        
    - 创建两个虚拟机，分别命名为 `RDMA-Node-1` 和 `RDMA-Node-2`。
        
    - **关键设置（非常重要）：** 在网络设置里，将网络模式改为 **“桥接模式 (Bridged Adapter)”**。这样这两台虚拟机才能像局域网里的两台独立电脑一样互相通信。
        
3. **确认互通：**
    
    - 启动两台虚拟机。
        
    - 在 Node-1 输入 `ip addr` 查看 IP（假设是 192.168.1.101）。
        
    - 在 Node-2 输入 `ping 192.168.1.101`。如果能 ping 通，实验台就搭好了！
        

---

### 第二步：安装“魔法药水”（驱动与工具）

**注意：以下步骤在两台虚拟机上都要执行。**

我们需要安装 RDMA 的核心库（Userspace 驱动）和测试工具（Perftest）。打开终端，输入：

Bash

```
# 1. 更新软件源
sudo apt-get update

# 2. 安装 RDMA 核心库和工具包
# rdma-core: 核心库
# ibverbs-utils: 基础管理工具
# perftest: 我们用来跑测试的工具 (ib_write_bw, ib_send_lat)
sudo apt-get install rdma-core ibverbs-utils perftest -y
```

---

### 第三步：施展“变形术”（配置 Soft-RoCE）

这是最神奇的一步。我们要欺骗操作系统，告诉它：“嘿，虽然我只有一张普通的网卡（比如 `enp0s3`），但你要把它当成一张昂贵的 RDMA 网卡来用！”

**在两台虚拟机上都执行：**

1. **加载内核模块：**
    
    Bash
    
    ```
    sudo modprobe rdma_rxe
    ```
    
    _(这一步没有任何输出就是好消息，说明加载成功)_
    
2. 找到你的网卡名字：
    
    输入 ip addr。找到那个有 IP 地址的网卡名字，通常叫 enp0s3、eth0 或者 ens33。我们假设它叫 enp0s3。
    
3. **绑定 Soft-RoCE (RXE)：**
    
    Bash
    
    ```
    # 语法：sudo rdma link add [自定义RDMA名字] type rxe netdev [你的物理网卡名]
    sudo rdma link add rxe0 type rxe netdev enp0s3
    ```
    
4. 见证奇迹：
    
    输入以下命令查看 RDMA 设备：
    
    Bash
    
    ```
    ibv_devinfo
    ```
    
    如果你看到输出了 `hca_id: rxe0`，并且状态是 `PORT_ACTIVE`，恭喜你！**你已经零成本拥有了一张“虚拟 RDMA 网卡”。**
    

---

### 第四步：见证时刻（运行测试）

现在我们有两台配好 RDMA 的机器了。

- **Node-1 (IP: 192.168.1.101)** 作为 **服务端 (Server)**。
    
- **Node-2 (IP: 192.168.1.102)** 作为 **客户端 (Client)**。
    

我们将测试 RDMA 最经典的指标：**延迟 (Latency)**。

1. **在 Node-1 (Server) 上输入：**
    
    Bash
    
    ```
    # -d rxe0 指定使用我们刚才创建的 RDMA 设备
    ib_send_lat -d rxe0
    ```
    
    _(它会进入等待状态，像一个守门员)_
    
2. **在 Node-2 (Client) 上输入：**
    
    Bash
    
    ```
    # 填入 Node-1 的 IP 地址
    ib_send_lat -d rxe0 192.168.1.101
    ```
    
3. 观察屏幕：
    
    屏幕上会瞬间刷出一堆数据。看最后几行：
    
    - 你看到的那个 `t_min` 或 `average` 的微秒数（us），就是通过 RDMA 协议传输数据的延迟！
        
    - 虽然因为是软件模拟，这个数字可能在 10us - 50us 之间（真的硬件只需 1us），但这证明了 **RDMA 协议栈已经跑通了！**
        

---

### 第五步：捕获“灵魂”（Wireshark 抓包）

你说想看 **BTH 头部**，这是最体现“懂行”的一步。

由于我们在虚拟机里只有命令行（CLI），最简单的办法是用 `tcpdump` 抓包，保存下来，传到你的宿主机（Windows/Mac）上用图形化的 Wireshark 看。

1. **在 Node-1 (Server) 上开始抓包：**
    
    Bash
    
    ```
    # 抓取 UDP 端口 4791 (RoCE v2 的默认端口)
    # -w rdma.pcap 表示保存为文件
    sudo tcpdump -i enp0s3 udp port 4791 -w rdma.pcap
    ```
    
2. **去 Node-2 再次运行一遍测试命令 (`ib_send_lat ...`)**，跑完后在 Node-1 按 `Ctrl+C` 停止抓包。
    
3. **把 `rdma.pcap` 复制出来**（可以用 `scp` 或者虚拟机共享文件夹），用你电脑上的 Wireshark 打开。
    
4. **解密时刻：**
    
    - 在 Wireshark 里，你随便点开一个 UDP 包。
        
    - Wireshark 通常能自动识别 RoCE。如果不能，右键点击 UDP -> "Decode As" -> 选择 "RoCEv2"。
        
    - 展开结构：`Ethernet` -> `IP` -> `UDP` -> **`Infiniband (RoCEv2)`**。
        
    - 在这里，你会看到 **Base Transport Header (BTH)**。看看里面的 `OpCode`，是不是写着 `Send` 或者 `RDMA Write`？
        

**这就是 RDMA 绕过操作系统，直接在网络上传输的“指令”！**

---

**可能遇到的“坑”（Troubleshooting）：**

- **报错 `Failed to create QP`：** 通常是防火墙问题。为了省事，直接在两台虚拟机上运行 `sudo ufw disable` 关闭防火墙。
    
- **虚拟机网络不通：** 确保VirtualBox里选的是“桥接网卡”，并且两台机IP在同一个网段。
    

一旦你跑通了这一步，你就已经超过了 90% 只是“听说过” RDMA 的人了。
